{% extends "base.html" %}

{% block title %}SketchDuel - Game{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-8 text-center">
        <h1>SketchDuel Game</h1>
        <p>Room Code: {{ room_code }}</p>

        <!-- Game Interface -->
        <div class="row">
            <!-- Drawing Canvas and Controls -->
            <div class="col-md-6">
                <div class="row flex-grow-1 mb-2">
                    <div class="col-12 col-md-12">
                        <canvas id="drawingCanvas" class="border w-100" style="max-height: 50vh;"></canvas>
                        <div id="tools" class="mt-2 d-flex flex-wrap gap-2" style="display: none;">
                            <input type="color" id="colorPicker" value="#000000">
                            <select id="brushSize" class="form-select w-auto">
                                <option value="2">Thin</option>
                                <option value="5" selected>Medium</option>
                                <option value="10">Thick</option>
                            </select>
                            <button id="eraserBtn" class="btn btn-secondary">Eraser</button>
                            <button id="undoBtn" class="btn btn-outline-secondary">Undo</button>
                            <button id="clearBtn" class="btn btn-danger">Clear</button>
                        </div>
                    </div>
                </div>
                <div id="prompt" class="mt-2" style="display: none;">Prompt: <span id="promptText"></span></div>
                <div id="timer" class="mt-2">Time Left: <span id="timeLeft">60</span>s</div>
            </div>

            <!-- Chat and Scores -->
            <div class="col-md-6">
                <h4>Chat</h4>
                <div id="chatBox" class="border p-2 mb-2" style="height: 300px; overflow-y: auto;"></div>
                <input type="text" id="guessInput" class="form-control mb-2" placeholder="Enter your guess">
                <button id="submitGuess" class="btn btn-primary">Submit Guess</button>
                <div class="mt-3">
                    <p>Score - Player 1: <span id="scoreP1">0</span> | Player 2: <span id="scoreP2">0</span></p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- JavaScript for Canvas and SocketIO -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
    const socket = io('/sketchduel');
    let isDrawing = false;
    let currentDrawerId = null;
    let canvas = document.getElementById('drawingCanvas');
    let ctx = canvas.getContext('2d');
    let drawingData = [];
    let history = []; // Stack for undo functionality
    let currentColor = '#000000'; // Default to black in hex
    let currentStroke = 5; // Default to Medium (5px)
    let isErasing = false;

    // Resize canvas to match its container
    function resizeCanvas() {
        canvas.height = canvas.offsetHeight;
        canvas.width = canvas.offsetWidth;
        redrawCanvas();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Update color and stroke when selections change
    document.getElementById('colorPicker').addEventListener('input', (e) => {
        currentColor = e.target.value;
        isErasing = false; // Disable eraser when changing color
        document.getElementById('eraserBtn').classList.remove('btn-primary');
    });

    document.getElementById('brushSize').addEventListener('change', (e) => {
        currentStroke = parseInt(e.target.value);
        isErasing = false; // Disable eraser when changing brush size
        document.getElementById('eraserBtn').classList.remove('btn-primary');
    });

    document.getElementById('eraserBtn').addEventListener('click', () => {
        isErasing = !isErasing;
        document.getElementById('eraserBtn').classList.toggle('btn-primary', isErasing);
        if (isErasing) {
            currentColor = '#FFFFFF'; // White for erasing on a white background
        } else {
            currentColor = document.getElementById('colorPicker').value;
        }
        ctx.strokeStyle = currentColor;
    });

    document.getElementById('undoBtn').addEventListener('click', () => {
        if (history.length > 1) {
            history.pop(); // Remove current state
            const previousState = history.pop();
            drawingData = previousState || [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redrawCanvas();
            socket.emit('update_drawing', { room_code: '{{ room_code }}', drawing_data: drawingData });
        }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawingData = [];
        history = [];
        socket.emit('update_drawing', { room_code: '{{ room_code }}', drawing_data: [] });
    });

    // Canvas Drawing Logic
    canvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        drawingData.push({ x, y, type: 'start', color: currentColor, stroke: currentStroke });
        history.push([...drawingData]); // Save state for undo
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentStroke;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDrawing) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawingData.push({ x, y, type: 'move', color: currentColor, stroke: currentStroke });
            ctx.lineTo(x, y);
            ctx.stroke();
            socket.emit('update_drawing', { room_code: '{{ room_code }}', drawing_data: drawingData });
            history.push([...drawingData]); // Update history on each move
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDrawing = false;
        ctx.beginPath();
    });

    // Redraw canvas from drawing data
    function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        let lastPoint = null;
        drawingData.forEach((point) => {
            if (point.type === 'start') {
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.strokeStyle = point.color;
                ctx.lineWidth = point.stroke;
                lastPoint = point;
            } else if (point.type === 'move' && lastPoint) {
                if (point.color !== lastPoint.color || point.stroke !== lastPoint.stroke) {
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, point.y);
                    ctx.strokeStyle = point.color;
                    ctx.lineWidth = point.stroke;
                }
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
                lastPoint = point;
            }
        });
    }

    // SocketIO Events
    socket.on('connect', () => {
        console.log('Connected to SketchDuel namespace');
        document.getElementById('tools').style.display = currentDrawerId == {{ session.get('player_id', 1) }} ? 'flex' : 'none'; // Show tools for drawer
    });

    socket.on('drawing_started', (data) => {
        currentDrawerId = data.drawer_id;
        document.getElementById('prompt').style.display = currentDrawerId == {{ session.get('player_id', 1) }} ? 'block' : 'none';
        document.getElementById('promptText').textContent = data.prompt;
        document.getElementById('timeLeft').textContent = data.time_left;
        document.getElementById('tools').style.display = currentDrawerId == {{ session.get('player_id', 1) }} ? 'flex' : 'none'; // Show tools for drawer
    });

    socket.on('drawing_update', (data) => {
        drawingData = data.drawing_data;
        redrawCanvas();
    });

    socket.on('switch_to_guessing', (data) => {
        document.getElementById('prompt').style.display = 'none';
        document.getElementById('tools').style.display = 'none'; // Hide tools during guessing
    });

    socket.on('guess_submitted', (data) => {
        const chatBox = document.getElementById('chatBox');
        chatBox.innerHTML += `<p>${data.guess} - ${data.correct ? 'Correct!' : 'Incorrect'}</p>`;
        chatBox.scrollTop = chatBox.scrollHeight;
        document.getElementById('scoreP1').textContent = data.score_p1;
        document.getElementById('scoreP2').textContent = data.score_p2;
    });

    socket.on('new_round', (data) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        currentDrawerId = data.drawer_id;
        document.getElementById('prompt').style.display = currentDrawerId == {{ session.get('player_id', 1) }} ? 'block' : 'none';
        document.getElementById('promptText').textContent = data.prompt;
        document.getElementById('timeLeft').textContent = data.time_left;
        drawingData = [];
        history = [];
        document.getElementById('tools').style.display = currentDrawerId == {{ session.get('player_id', 1) }} ? 'flex' : 'none'; // Show tools for new drawer
    });

    socket.on('timer_updated', (data) => {
        document.getElementById('timeLeft').textContent = data.time_left;
    });

    // Handle redirect to scoreboard when game ends
    socket.on('redirect', (data) => {
        window.location.href = data.url;
    });

    document.getElementById('submitGuess').addEventListener('click', () => {
        const guess = document.getElementById('guessInput').value;
        if (guess) {
            socket.emit('submit_guess', { room_code: '{{ room_code }}', guess: guess });
            document.getElementById('guessInput').value = '';
        }
    });

    // Start the game
    socket.emit('start_drawing', { room_code: '{{ room_code }}' });
</script>
{% endblock %}